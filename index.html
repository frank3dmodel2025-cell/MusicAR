<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Art AR — WebXR & Fallback</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root{--bg:#f7f3ed;--panel:#ffffffcc;--accent:#4f46e5;--muted:#6b7280}
  html,body{height:100%;margin:0;font-family:'Poppins',sans-serif;background:var(--bg);overflow:hidden}
  #container{position:fixed;inset:0;display:flex;align-items:stretch;}
  canvas{display:block;width:100%;height:100vh;z-index:10}
  video#cameraFeed{position:fixed;inset:0;width:100%;height:100%;object-fit:cover;z-index:5;display:none;}
  .ui{
    position:fixed;right:16px;top:16px;z-index:60;
    background:var(--panel);backdrop-filter:blur(6px);border-radius:12px;padding:12px;box-shadow:0 8px 30px rgba(20,20,40,0.12);
    min-width:180px;
  }
  .ui h3{margin:0 0 6px 0;font-size:14px}
  .btn{display:inline-block;padding:8px 12px;border-radius:10px;border:none;background:var(--accent);color:#fff;font-weight:600;cursor:pointer}
  .btn.gray{background:#e5e7eb;color:#111}
  .gallery{display:flex;gap:8px;margin-top:8px;overflow:hidden}
  .thumb{width:48px;height:48px;border-radius:6px;object-fit:cover;cursor:pointer;border:2px solid transparent}
  .thumb.selected{border-color:var(--accent)}
  #placementHint{position:fixed;left:50%;transform:translateX(-50%);bottom:20px;background:rgba(0,0,0,0.6);color:#fff;padding:8px 12px;border-radius:999px;z-index:60;display:none}
  #note{font-size:12px;color:var(--muted);margin-top:8px}
  .small{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
  <div id="container">
    <video id="cameraFeed" autoplay playsinline muted></video>
    <div id="three-dom"></div>
    <canvas id="xr-canvas"></canvas>
  </div>

  <div class="ui" id="ui-panel">
    <h3>Art AR — Gallery</h3>
    <div>
      <button id="enter-ar-btn" class="btn">Enter AR</button>
      <button id="start-sim-btn" class="btn gray">Simulate AR</button>
    </div>

    <div id="gallery" class="gallery" aria-label="Art gallery" style="margin-top:10px">
      <!-- thumbnails -->
      <img class="thumb selected" data-src="https://images.unsplash.com/photo-1503023345310-bd7c1de61c7d?w=1024&q=80&auto=format&fit=crop" src="https://images.unsplash.com/photo-1503023345310-bd7c1de61c7d?w=200&q=60&auto=format&fit=crop" alt="Art 1">
      <img class="thumb" data-src="https://images.unsplash.com/photo-1513353449046-5f1c22e5a9e9?w=1024&q=80&auto=format&fit=crop" src="https://images.unsplash.com/photo-1513353449046-5f1c22e5a9e9?w=200&q=60&auto=format&fit=crop" alt="Art 2">
      <img class="thumb" data-src="https://images.unsplash.com/photo-1519681393784-d120267933ba?w=1024&q=80&auto=format&fit=crop" src="https://images.unsplash.com/photo-1519681393784-d120267933ba?w=200&q=60&auto=format&fit=crop" alt="Art 3">
    </div>

    <div id="note" class="small">Select an artwork then <strong>Enter AR</strong>. Tap the reticle to place the frame. Use pinch to scale and drag to rotate after placement.</div>
  </div>

  <div id="placementHint">Move your phone to detect surfaces</div>

  <!-- Three.js + modules -->
  <script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';
  import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/loaders/GLTFLoader.js';
  import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/webxr/ARButton.js';
  import { DeviceOrientationControls } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/controls/DeviceOrientationControls.js';

  /*****************************************************************************
   *  Overview:
   *  - Try WebXR immersive-ar first (hit-test + anchors)
   *  - If not supported, provide simulated AR fallback using camera + gyro
   *  - Art object: a frame (thin box) + inner plane with chosen texture
   *  - After placing: allow rotate (one-finger drag) and scale (pinch)
   *****************************************************************************/

  // DOM
  const enterARBtn = document.getElementById('enter-ar-btn');
  const startSimBtn = document.getElementById('start-sim-btn');
  const placementHint = document.getElementById('placementHint');
  const gallery = document.getElementById('gallery');
  const cameraFeed = document.getElementById('cameraFeed');

  // THREE core
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 50);
  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, canvas: document.getElementById('xr-canvas') });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.xr.enabled = true;
  document.getElementById('three-dom').appendChild(renderer.domElement);

  // Lighting
  const hemi = new THREE.HemisphereLight(0xffffff,0xbbbbff,0.8); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff,0.8); dir.position.set(1,3,2); dir.castShadow=true; scene.add(dir);

  // Reticle (placement indicator)
  const reticle = new THREE.Mesh(
    new THREE.RingGeometry(0.12, 0.18, 32).rotateX(-Math.PI/2),
    new THREE.MeshBasicMaterial({ color:0xffff00, transparent:true, opacity:0.9 })
  );
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  // Model container & placed object
  let placedRoot = null;      // Object3D parent for the placed artwork (anchored)
  let placedAnchor = null;    // XRAnchor if available
  let tempModel = null;       // internal 3D model (frame + plane)
  let currentTextureURL = gallery.querySelector('.thumb.selected').dataset.src;

  // GLTF loader (if later you want a frame model)
  const loader = new GLTFLoader();

  // DeviceOrientation fallback controls
  let deviceControls = null;
  let simActive = false;
  let simCameraStream = null;

  // Helpers for gestures
  let ongoingTouches = [];
  function copyTouch(t){ return {id:t.identifier, x:t.clientX, y:t.clientY}; }
  function getTouchById(id){ return ongoingTouches.find(t=>t.id===id); }
  function updateTouch(id,x,y){ const t = getTouchById(id); if(t){ t.x=x; t.y=y; } }
  function removeTouch(id){ ongoingTouches = ongoingTouches.filter(t=>t.id!==id); }

  // Resize
  window.addEventListener('resize', ()=> {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  /*********************** Build Artwork (frame + plane) *************************/
  function buildArtwork(textureURL){
    // Root group
    const root = new THREE.Group();

    // Plane for art (1 unit width x 1.5 height base)
    const width = 1.0, height = 1.5;
    const geometry = new THREE.PlaneGeometry(width, height);
    const texture = new THREE.TextureLoader().load(textureURL);
    texture.encoding = THREE.sRGBEncoding;
    const material = new THREE.MeshStandardMaterial({ map: texture, roughness:0.6, metalness:0.0 });
    const plane = new THREE.Mesh(geometry, material);
    plane.position.set(0,0,0.02); // slight offset forward
    plane.castShadow = true;
    plane.receiveShadow = false;
    root.add(plane);

    // Simple thin frame (a slightly bigger box)
    const frameGeom = new THREE.BoxGeometry(width + 0.06, height + 0.06, 0.05);
    const frameMat = new THREE.MeshStandardMaterial({ color:0x111111, metalness:0.2, roughness:0.6 });
    const frame = new THREE.Mesh(frameGeom, frameMat);
    frame.position.set(0,0,-0.01);
    root.add(frame);

    // Add subtle backplate to prevent see-through
    const backGeom = new THREE.PlaneGeometry(width+0.08, height+0.08);
    const backMat = new THREE.MeshStandardMaterial({ color:0x0e0e0e });
    const back = new THREE.Mesh(backGeom, backMat);
    back.position.set(0,0,-0.055);
    root.add(back);

    // Scale root to a comfortable default (we'll allow user scaling)
    root.scale.setScalar(1.0);

    return root;
  }

  /************************** WebXR: Hit test & anchors **************************/
  let xrHitTestSource = null;
  let xrRefSpace = null;

  async function startXR(){
    if(!navigator.xr) {
      alert('WebXR not supported on this device/browser. Use "Simulate AR" button for fallback.');
      return;
    }
    try{
      const supported = await navigator.xr.isSessionSupported('immersive-ar');
      if(!supported){
        alert('immersive-ar not supported. Try latest Chrome on Android with ARCore.');
        return;
      }
    }catch(e){
      console.warn('XR check failed', e);
      alert('WebXR check failed.');
      return;
    }

    // Create session via ARButton helper (but we want more control, so we'll request manually)
    const session = await navigator.xr.requestSession('immersive-ar', {
      requiredFeatures: ['hit-test', 'local-floor', 'anchors'],
      optionalFeatures: ['dom-overlay'],
      domOverlay: { root: document.body }
    });

    renderer.xr.setSession(session);
    // reference space for placing content
    xrRefSpace = await session.requestReferenceSpace('local-floor');

    // request a hit test source using 'viewer' reference space
    const viewerSpace = await session.requestReferenceSpace('viewer');
    xrHitTestSource = await session.requestHitTestSource({ space: viewerSpace });

    // show placement hint
    placementHint.style.display = 'block';

    // react to session end
    session.addEventListener('end', ()=> {
      cleanupXR();
      placementHint.style.display = 'none';
    });

    // Input: handle select event (tap) to place object
    session.addEventListener('select', (ev) => {
      // place at reticle's current pose
      if(reticle.visible){
        placeArtworkAtReticle(ev.frame);
      }
    });

    // start render loop via renderer.setAnimationLoop
    renderer.setAnimationLoop(onXRFrame);
  }

  function cleanupXR(){
    // remove anchor & placed object if any (but we may want to keep it; here we keep it)
    xrHitTestSource = null;
    xrRefSpace = null;
    renderer.setAnimationLoop(null);
    renderer.xr.setSession(null);
  }

  function onXRFrame(time, frame){
    const session = frame.session;
    // get viewer pose relative to reference space
    const pose = frame.getViewerPose(xrRefSpace);
    if(!pose){
      renderer.render(scene, camera);
      return;
    }

    // run hit test
    if(xrHitTestSource){
      const hitResults = frame.getHitTestResults(xrHitTestSource);
      if(hitResults.length > 0 && !placedRoot){
        const hit = hitResults[0];
        const hitPose = hit.getPose(xrRefSpace);
        // position reticle
        reticle.visible = true;
        reticle.matrix.fromArray(hitPose.transform.matrix);
      } else if(hitResults.length > 0 && placedRoot){
        // hide reticle if already placed
        reticle.visible = false;
      } else {
        reticle.visible = false;
      }
    }

    // If we have an anchor with tracking, update placedRoot using anchor's pose if available:
    if(placedRoot && placedAnchor && frame.getPose){
      // try to get anchor pose (anchors API might provide anchor.anchorSpace)
      try{
        const anchorPose = frame.getPose(placedAnchor.anchorSpace || placedAnchor, xrRefSpace);
        if(anchorPose){
          placedRoot.matrix.fromArray(anchorPose.transform.matrix);
          placedRoot.matrix.decompose(placedRoot.position, placedRoot.quaternion, placedRoot.scale);
        }
      }catch(e){ /* ignore if not available */ }
    }

    renderer.render(scene, camera);
  }

  /************************** Place artwork and anchors **************************/
  // Called when user taps/selects while reticle visible. We create a placedRoot and attempt to create an XRAnchor.
  async function placeArtworkAtReticle(frame){
    if(!reticle.visible) return;
    // create placedRoot at reticle matrix
    placedRoot = new THREE.Group();
    placedRoot.matrixAutoUpdate = false;
    placedRoot.matrix.copy(reticle.matrix);
    placedRoot.matrix.decompose(placedRoot.position, placedRoot.quaternion, placedRoot.scale);

    // Create the artwork model from current selection
    tempModel = buildArtwork(currentTextureURL);
    // center the art so it faces camera: rotate to lay flat against plane's normal
    // reticle is aligned with surface normal, so we just add model
    placedRoot.add(tempModel);
    scene.add(placedRoot);

    // Try to create XRAnchor (if anchors supported)
    try{
      const session = renderer.xr.getSession();
      if(session && session.requestAnchor){
        // Many implementations use frame.createAnchor, but session.requestAnchor is also used
        const frameOfRef = xrRefSpace;
        // Use the last frame's hit test to get the transform - but here assume reticle matrix
        const transform = new XRRigidTransform(); // identity
        // Simpler approach: request anchor from reticle's pose using frame (if available)
        // We'll attempt to use createAnchor via frame (works in some browsers)
        const viewerPose = frame ? frame.getViewerPose(xrRefSpace) : null;
        // Preferred: ask frame to create anchor from hit result - but we can't pass hit here, so skip
        // Alternatively, use anchors via session.requestAnchor if available:
        if(session.requestAnchor){
          // Use matrix of reticle to build pose:
          const m = reticle.matrix.elements;
          const pose = new XRRigidTransform({
            x: m[12], y: m[13], z: m[14]
          }, {
            x: 0, y: 0, z: 0, w: 1
          }); // simple pose - orientation not exact but OK
          // request anchor
          try{
            const anchor = await session.requestAnchor(pose, xrRefSpace);
            placedAnchor = anchor;
            // anchor.anchorSpace available in some implementations
            console.log('Anchor created', anchor);
          }catch(e){ console.warn('requestAnchor failed', e); placedAnchor = null; }
        }
      }
    }catch(e){
      console.warn('anchor creation failed', e);
      placedAnchor = null;
    }

    // Hide reticle and hint after placement
    reticle.visible = false;
    placementHint.style.display = 'none';

    // Enable touch interactions on the renderer canvas for rotate/scale
    enableTouchInteractions();
  }

  /************************ Touch interactions for placed object ************************/
  function enableTouchInteractions(){
    const canvas = renderer.domElement;

    canvas.addEventListener('touchstart', onTouchStart, {passive:false});
    canvas.addEventListener('touchmove', onTouchMove, {passive:false});
    canvas.addEventListener('touchend', onTouchEnd, {passive:false});
  }
  function onTouchStart(e){
    if(!placedRoot) return;
    // track touches
    ongoingTouches = [];
    for(const t of e.touches) ongoingTouches.push(copyTouch(t));
    e.preventDefault();
  }
  function onTouchMove(e){
    if(!placedRoot) return;
    e.preventDefault();
    // single finger -> rotate around Y
    if(e.touches.length === 1 && ongoingTouches.length === 1){
      const t = e.touches[0];
      const prev = ongoingTouches[0];
      const dx = t.clientX - prev.x;
      const rotY = dx * 0.005; // sensitivity
      placedRoot.rotation.y -= rotY;
      // update tracked touch
      updateTouch(ongoingTouches[0].id, t.clientX, t.clientY);
    }
    // two fingers -> pinch to scale
    else if(e.touches.length === 2){
      const t0 = e.touches[0], t1 = e.touches[1];
      const prev0 = getTouchById(ongoingTouches[0].id) || copyTouch(e.touches[0]);
      const prev1 = getTouchById(ongoingTouches[1].id) || copyTouch(e.touches[1]);

      const prevDist = Math.hypot(prev1.x - prev0.x, prev1.y - prev0.y);
      const newDist = Math.hypot(t1.clientX - t0.clientX, t1.clientY - t0.clientY);
      const scaleFactor = newDist / prevDist;
      // clamp scale
      const newScale = THREE.MathUtils.clamp(placedRoot.scale.x * scaleFactor, 0.2, 6);
      placedRoot.scale.setScalar(newScale);

      // update tracked touches positions
      updateTouch(ongoingTouches[0].id, t0.clientX, t0.clientY);
      updateTouch(ongoingTouches[1].id, t1.clientX, t1.clientY);
    }
  }
  function onTouchEnd(e){
    // update ongoing touches
    if(e.changedTouches){
      for(const t of e.changedTouches) removeTouch(t.identifier);
    }
    if(e.touches.length === 0) ongoingTouches = [];
  }

  /************************** Simulated AR fallback **************************/
  async function startSimulatedAR(){
    // try to start camera feed as background
    try{
      simCameraStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio:false });
      cameraFeed.srcObject = simCameraStream;
      cameraFeed.style.display = 'block';
    }catch(e){
      console.warn('Camera fallback failed', e);
      alert('Camera access required for simulated AR fallback.');
      return;
    }

    // Activate DeviceOrientation controls for camera movement feel
    deviceControls = new DeviceOrientationControls(camera);
    deviceControls.connect();

    // place reticle at center (we will use screenToWorld conversion)
    reticle.visible = true;
    placementHint.style.display = 'block';
    simActive = true;

    // start render loop
    renderer.setAnimationLoop(simulateFrame);
  }

  function simulateFrame(){
    // simple reticle behavior: keep reticle 2m in front of camera
    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    const pos = new THREE.Vector3().copy(camera.position).add(dir.multiplyScalar(2.0));
    reticle.position.copy(pos);
    reticle.quaternion.copy(camera.quaternion);
    reticle.updateMatrix();

    renderer.render(scene,camera);
  }

  function stopSimulatedAR(){
    if(simCameraStream){
      simCameraStream.getTracks().forEach(t=>t.stop());
      cameraFeed.srcObject = null;
      cameraFeed.style.display = 'none';
    }
    if(deviceControls) deviceControls.dispose();
    simActive = false;
    renderer.setAnimationLoop(null);
    reticle.visible = false;
    placementHint.style.display = 'none';
  }

  /************************** UI bindings **************************/
  // Enter AR button using WebXR when available
  enterARBtn.addEventListener('click', async () => {
    // If already in XR, ignore
    if(renderer.xr.isPresenting) return;
    try{
      await startXR();
      // scene initial state for XR: if user hasn't created a model yet, create one but keep hidden
      if(!tempModel) currentTextureURL = gallery.querySelector('.thumb.selected').dataset.src;
      // renderer will run the XR loop
    }catch(e){
      console.error('startXR error', e);
      alert('Failed to start AR session: ' + e.message);
    }
  });

  // Simulated AR fallback
  startSimBtn.addEventListener('click', ()=>{
    if(simActive) { stopSimulatedAR(); startSimBtn.textContent='Simulate AR'; }
    else { startSimulatedAR(); startSimBtn.textContent='Stop Simulation'; }
  });

  // Gallery selection change
  gallery.addEventListener('click', (e)=>{
    const t = e.target.closest('.thumb');
    if(!t) return;
    // mark selection
    gallery.querySelectorAll('.thumb').forEach(i => i.classList.remove('selected'));
    t.classList.add('selected');
    currentTextureURL = t.dataset.src;
    // if artwork placed already, update texture on the fly
    if(tempModel){
      // find plane child (plane is first child per buildArtwork)
      const plane = tempModel.children.find(c => c.geometry && c.geometry.type === 'PlaneGeometry');
      if(plane) {
        const newTex = new THREE.TextureLoader().load(currentTextureURL);
        newTex.encoding = THREE.sRGBEncoding;
        plane.material.map = newTex;
        plane.material.needsUpdate = true;
      }
    }
  });

  /************************** Utility: Screen->World (for simulated) **************************/
  function screenToWorld(x,y, distance=2){
    // convert screen coords to NDC
    const ndc = new THREE.Vector3((x/window.innerWidth)*2-1, -(y/window.innerHeight)*2+1, 0.5);
    ndc.unproject(camera);
    const dir = ndc.sub(camera.position).normalize();
    return camera.position.clone().add(dir.multiplyScalar(distance));
  }

  // When user taps the screen in simulated mode, place the model at reticle location
  renderer.domElement.addEventListener('touchend', (ev)=>{
    // double-tap detection for placement in simulated mode
    const now = performance.now();
    if(simActive && now - (renderer.domElement._lastTap||0) < 300){
      // place at reticle
      placeSimulatedAtReticle();
      renderer.domElement._lastTap = 0;
    } else {
      renderer.domElement._lastTap = now;
    }
  });

  function placeSimulatedAtReticle(){
    if(!simActive) return;
    if(placedRoot) {
      // already placed — maybe show message
      placementHint.style.display = 'none';
      return;
    }
    placedRoot = new THREE.Group();
    // position at reticle position and orientation
    placedRoot.position.copy(reticle.position);
    placedRoot.quaternion.copy(reticle.quaternion);
    // add model
    tempModel = buildArtwork(currentTextureURL);
    placedRoot.add(tempModel);
    scene.add(placedRoot);
    placementHint.style.display = 'none';
    // allow touch interactions
    enableTouchInteractions();
  }

  /************************** Start initial scene (non-XR) **************************/
  // set camera default position (so device orientation/OrbitControls has reference)
  camera.position.set(0, 1.6, 3);
  // Add a subtle ground to catch shadows (not visible when camera passthrough)
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(20,20), new THREE.MeshStandardMaterial({color:0xffffff,transparent:true,opacity:0}));
  ground.rotation.x = -Math.PI/2; ground.position.y = -1.2; ground.receiveShadow=true;
  scene.add(ground);

  // keep a small animation loop so the scene shows before XR starts
  renderer.setAnimationLoop(()=> {
    renderer.render(scene,camera);
  });

  /************************** Notes for tester **************************/
  // 1) To test WebXR on Android: use Chrome for Android + ARCore-supporting phone.
  // 2) Host this page on HTTPS (GitHub Pages / Vercel / Netlify). WebXR requires secure context.
  // 3) If device doesn't support WebXR immersive-ar, click "Simulate AR" and use double-tap to place.
  // 4) After placement: drag one finger to rotate, pinch to scale. Change artwork via gallery.
  // 5) Anchors support is attempted but browser support varies; the app falls back to keeping the placed object in scene.
  //
  // Implementation details are commented inside the code blocks above.

  </script>
</body>
</html>
