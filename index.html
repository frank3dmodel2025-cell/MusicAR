<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Web AR</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            touch-action: none;
            background: #000;
        }

        /* Video Background for AR */
        #video {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
            display: none;
        }

        /* Three.js Canvas */
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        /* UI Container */
        .ui-container {
            position: fixed;
            z-index: 10;
            pointer-events: none;
        }

        .ui-container > * {
            pointer-events: auto;
        }

        /* Top Bar */
        .top-bar {
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(180deg, rgba(0,0,0,0.6) 0%, transparent 100%);
        }

        .btn {
            background: rgba(255,255,255,0.9);
            border: none;
            border-radius: 12px;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .btn:active {
            transform: scale(0.95);
            background: rgba(255,255,255,0.7);
        }

        .btn-icon {
            padding: 12px;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .btn-primary {
            background: rgba(0,122,255,0.9);
            color: white;
        }

        .btn-primary:active {
            background: rgba(0,122,255,0.7);
        }

        /* Center Reticle */
        .reticle {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255,255,255,0.8);
            border-radius: 50%;
            z-index: 5;
            pointer-events: none;
            animation: pulse 2s ease-in-out infinite;
        }

        .reticle::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background: rgba(255,255,255,0.9);
            border-radius: 50%;
        }

        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
        }

        /* Bottom Panel */
        .bottom-panel {
            bottom: 0;
            left: 0;
            right: 0;
            padding: 20px;
            background: linear-gradient(0deg, rgba(0,0,0,0.8) 0%, transparent 100%);
        }

        .model-selector {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            margin-bottom: 15px;
            padding-bottom: 10px;
            -webkit-overflow-scrolling: touch;
        }

        .model-card {
            min-width: 80px;
            height: 80px;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .model-card.active {
            background: rgba(0,122,255,0.3);
            border-color: rgba(0,122,255,1);
        }

        .model-card span {
            color: white;
            font-size: 12px;
            margin-top: 5px;
            text-align: center;
        }

        /* Controls */
        .controls {
            background: rgba(0,0,0,0.6);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 10px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s;
        }

        .controls.show {
            max-height: 300px;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group label {
            color: white;
            font-size: 12px;
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        input[type="range"] {
            width: 100%;
            height: 30px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
        }

        input[type="range"]::-webkit-slider-track {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            margin-top: -8px;
        }

        .button-row {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .button-row .btn {
            flex: 1;
        }

        /* Notification */
        .notification {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 25px;
            font-size: 14px;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .notification.show {
            opacity: 1;
        }

        /* Permission Overlay */
        .permission-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 100;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 30px;
        }

        .permission-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 400px;
            text-align: center;
        }

        .permission-content h2 {
            margin-bottom: 15px;
            color: #333;
        }

        .permission-content p {
            color: #666;
            margin-bottom: 25px;
            line-height: 1.5;
        }

        /* Loading */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 16px;
            z-index: 50;
            text-align: center;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Dark Mode */
        body.dark-mode .btn {
            background: rgba(50,50,50,0.9);
            color: white;
        }

        body.dark-mode .btn:active {
            background: rgba(50,50,50,0.7);
        }

        /* Instructions */
        .instructions {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 25px;
            font-size: 14px;
            z-index: 5;
            text-align: center;
            max-width: 80%;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <!-- Camera Video -->
    <video id="video" playsinline autoplay muted></video>

    <!-- Three.js Canvas -->
    <canvas id="canvas"></canvas>

    <!-- Reticle -->
    <div class="reticle" id="reticle"></div>

    <!-- Instructions -->
    <div class="instructions" id="instructions">
        Tap screen to place model
    </div>

    <!-- Top Bar -->
    <div class="ui-container top-bar">
        <button class="btn btn-icon" id="arToggle">üì∑</button>
        <button class="btn btn-icon" id="themeToggle">üåô</button>
    </div>

    <!-- Bottom Panel -->
    <div class="ui-container bottom-panel">
        <div class="model-selector" id="modelSelector"></div>
        
        <div class="controls" id="controls">
            <div class="control-group">
                <label>Scale</label>
                <input type="range" id="scaleSlider" min="0.1" max="3" step="0.1" value="1">
            </div>
            <div class="control-group">
                <label>Rotation Y</label>
                <input type="range" id="rotationSlider" min="0" max="360" step="1" value="0">
            </div>
            <div class="control-group">
                <label>Height</label>
                <input type="range" id="heightSlider" min="-2" max="2" step="0.1" value="0">
            </div>
            <div class="button-row">
                <button class="btn" id="relocateBtn">üìç Relocate</button>
                <button class="btn" id="resetBtn">üîÑ Reset</button>
            </div>
        </div>

        <button class="btn btn-primary" id="controlsToggle" style="width: 100%;">
            ‚öôÔ∏è Controls
        </button>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification"></div>

    <!-- Permission Overlay -->
    <div class="permission-overlay" id="permissionOverlay">
        <div class="permission-content">
            <h2>Motion Sensors Required</h2>
            <p>This AR experience needs access to your device motion sensors for the best experience.</p>
            <button class="btn btn-primary" id="requestPermission" style="width: 100%;">
                Enable Motion Tracking
            </button>
        </div>
    </div>

    <!-- Loading -->
    <div class="loading" id="loading">
        <div class="spinner"></div>
        <div>Loading AR Experience...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============================================
        // GLOBAL STATE & CONFIGURATION
        // ============================================
        
        const state = {
            arMode: false,
            motionEnabled: false,
            modelPlaced: false,
            selectedModel: 'duck',
            currentModel: null,
            isDragging: false,
            isRelocating: false,
            initialPinchDistance: 0,
            initialScale: 1
        };

        const models = [
            { id: 'duck', name: 'ü¶Ü Duck', url: 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF-Binary/Duck.glb' },
            { id: 'helmet', name: '‚õëÔ∏è Helmet', url: 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/DamagedHelmet/glTF-Binary/DamagedHelmet.glb' },
            { id: 'boombox', name: 'üìª BoomBox', url: 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/BoomBox/glTF-Binary/BoomBox.glb' }
        ];

        // ============================================
        // THREE.JS SCENE SETUP
        // ============================================
        
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('canvas'), 
            antialias: true, 
            alpha: true 
        });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        camera.position.set(0, 1.6, 0);

        // ============================================
        // LIGHTING SETUP
        // ============================================
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -10;
        directionalLight.shadow.camera.right = 10;
        directionalLight.shadow.camera.top = 10;
        directionalLight.shadow.camera.bottom = -10;
        scene.add(directionalLight);

        // ============================================
        // SHADOW PLANE (Invisible plane for shadows)
        // ============================================
        
        const shadowPlaneGeometry = new THREE.PlaneGeometry(100, 100);
        const shadowPlaneMaterial = new THREE.ShadowMaterial({ opacity: 0.3 });
        const shadowPlane = new THREE.Mesh(shadowPlaneGeometry, shadowPlaneMaterial);
        shadowPlane.rotation.x = -Math.PI / 2;
        shadowPlane.position.y = 0;
        shadowPlane.receiveShadow = true;
        scene.add(shadowPlane);

        // ============================================
        // MODEL LOADING
        // ============================================
        
        const loader = new THREE.GLTFLoader();
        const loadedModels = {};

        async function loadModel(modelInfo) {
            if (loadedModels[modelInfo.id]) {
                return loadedModels[modelInfo.id].clone();
            }

            return new Promise((resolve, reject) => {
                loader.load(
                    modelInfo.url,
                    (gltf) => {
                        const model = gltf.scene;
                        model.traverse((node) => {
                            if (node.isMesh) {
                                node.castShadow = true;
                                node.receiveShadow = true;
                            }
                        });

                        // Center and scale model
                        const box = new THREE.Box3().setFromObject(model);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z);
                        const scale = 1.5 / maxDim;
                        
                        model.position.sub(center);
                        model.scale.setScalar(scale);

                        loadedModels[modelInfo.id] = model;
                        resolve(model.clone());
                    },
                    undefined,
                    reject
                );
            });
        }

        // ============================================
        // AR CAMERA SETUP
        // ============================================
        
        const video = document.getElementById('video');

        async function startCamera() {
            try {
                const constraints = {
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                };

                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                video.style.display = 'block';
                return true;
            } catch (err) {
                console.error('Camera error:', err);
                showNotification('Camera access denied');
                return false;
            }
        }

        function stopCamera() {
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
                video.style.display = 'none';
            }
        }

        // ============================================
        // DEVICE ORIENTATION CONTROLS
        // ============================================
        
        let deviceOrientation = { alpha: 0, beta: 0, gamma: 0 };
        let screenOrientation = 0;

        function handleOrientation(e) {
            if (!state.motionEnabled || !state.modelPlaced) return;
            
            deviceOrientation.alpha = e.alpha || 0;
            deviceOrientation.beta = e.beta || 0;
            deviceOrientation.gamma = e.gamma || 0;
        }

        function handleScreenOrientation() {
            screenOrientation = window.orientation || 0;
        }

        async function requestMotionPermission() {
            if (typeof DeviceOrientationEvent !== 'undefined' && 
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const permission = await DeviceOrientationEvent.requestPermission();
                    if (permission === 'granted') {
                        enableMotionTracking();
                        document.getElementById('permissionOverlay').style.display = 'none';
                    }
                } catch (err) {
                    console.error('Permission denied:', err);
                    showNotification('Motion permission denied');
                }
            } else {
                enableMotionTracking();
                document.getElementById('permissionOverlay').style.display = 'none';
            }
        }

        function enableMotionTracking() {
            state.motionEnabled = true;
            window.addEventListener('deviceorientation', handleOrientation, true);
            window.addEventListener('orientationchange', handleScreenOrientation, true);
            showNotification('Motion tracking enabled');
        }

        // ============================================
        // MODEL PLACEMENT & POSITIONING
        // ============================================
        
        async function placeModel() {
            if (state.modelPlaced && !state.isRelocating) return;

            const modelInfo = models.find(m => m.id === state.selectedModel);
            
            try {
                showLoading(true);
                
                // Remove existing model
                if (state.currentModel) {
                    scene.remove(state.currentModel);
                }

                // Load new model
                const model = await loadModel(modelInfo);
                
                // Place model in front of camera
                const distance = 2;
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(camera.quaternion);
                
                const position = camera.position.clone().add(direction.multiplyScalar(distance));
                position.y = 0; // Place on ground
                
                model.position.copy(position);
                model.visible = true;

                scene.add(model);
                state.currentModel = model;
                state.modelPlaced = true;
                state.isRelocating = false;

                document.getElementById('reticle').style.display = 'none';
                document.getElementById('instructions').style.display = 'none';
                
                showNotification(`${modelInfo.name} placed!`);
                showLoading(false);
            } catch (err) {
                console.error('Error placing model:', err);
                showNotification('Error loading model');
                showLoading(false);
            }
        }

        function resetModel() {
            if (state.currentModel) {
                scene.remove(state.currentModel);
                state.currentModel = null;
                state.modelPlaced = false;
                document.getElementById('reticle').style.display = 'block';
                document.getElementById('instructions').style.display = 'block';
                document.getElementById('scaleSlider').value = 1;
                document.getElementById('rotationSlider').value = 0;
                document.getElementById('heightSlider').value = 0;
                showNotification('Model reset');
            }
        }

        // ============================================
        // TOUCH GESTURES
        // ============================================
        
        let touchStartPos = { x: 0, y: 0 };
        let lastTouchTime = 0;

        function getTouchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function handleTouchStart(e) {
            if (e.touches.length === 1) {
                touchStartPos.x = e.touches[0].clientX;
                touchStartPos.y = e.touches[0].clientY;
                
                // Double tap detection
                const now = Date.now();
                if (now - lastTouchTime < 300) {
                    placeModel();
                }
                lastTouchTime = now;
                
                state.isDragging = true;
            } else if (e.touches.length === 2 && state.modelPlaced) {
                state.initialPinchDistance = getTouchDistance(e.touches);
                state.initialScale = state.currentModel.scale.x;
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();

            if (e.touches.length === 1 && state.isDragging && state.modelPlaced) {
                const deltaX = e.touches[0].clientX - touchStartPos.x;
                state.currentModel.rotation.y += deltaX * 0.01;
                touchStartPos.x = e.touches[0].clientX;
            } else if (e.touches.length === 2 && state.modelPlaced) {
                const currentDistance = getTouchDistance(e.touches);
                const scale = (currentDistance / state.initialPinchDistance) * state.initialScale;
                state.currentModel.scale.setScalar(Math.max(0.1, Math.min(3, scale)));
                document.getElementById('scaleSlider').value = state.currentModel.scale.x;
            }
        }

        function handleTouchEnd(e) {
            state.isDragging = false;
        }

        // ============================================
        // UI CONTROLS
        // ============================================
        
        function showNotification(message) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.classList.add('show');
            setTimeout(() => notification.classList.remove('show'), 2000);
        }

        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        function updateSliders() {
            if (!state.currentModel) return;

            const scale = parseFloat(document.getElementById('scaleSlider').value);
            const rotation = parseFloat(document.getElementById('rotationSlider').value);
            const height = parseFloat(document.getElementById('heightSlider').value);

            state.currentModel.scale.setScalar(scale);
            state.currentModel.rotation.y = rotation * Math.PI / 180;
            state.currentModel.position.y = height;
        }

        // ============================================
        // UI EVENT LISTENERS
        // ============================================
        
        // Model selector
        const modelSelector = document.getElementById('modelSelector');
        models.forEach(model => {
            const card = document.createElement('div');
            card.className = 'model-card' + (model.id === state.selectedModel ? ' active' : '');
            card.innerHTML = `<span>${model.name}</span>`;
            card.onclick = () => {
                document.querySelectorAll('.model-card').forEach(c => c.classList.remove('active'));
                card.classList.add('active');
                state.selectedModel = model.id;
                if (state.modelPlaced) {
                    placeModel();
                }
            };
            modelSelector.appendChild(card);
        });

        // Controls toggle
        document.getElementById('controlsToggle').onclick = () => {
            const controls = document.getElementById('controls');
            controls.classList.toggle('show');
        };

        // Sliders
        document.getElementById('scaleSlider').oninput = updateSliders;
        document.getElementById('rotationSlider').oninput = updateSliders;
        document.getElementById('heightSlider').oninput = updateSliders;

        // Relocate button
        document.getElementById('relocateBtn').onclick = () => {
            state.isRelocating = true;
            document.getElementById('reticle').style.display = 'block';
            document.getElementById('instructions').textContent = 'Tap to relocate model';
            document.getElementById('instructions').style.display = 'block';
            showNotification('Move phone and tap to relocate');
        };

        // Reset button
        document.getElementById('resetBtn').onclick = resetModel;

        // AR toggle
        document.getElementById('arToggle').onclick = async () => {
            state.arMode = !state.arMode;
            if (state.arMode) {
                await startCamera();
                renderer.setClearAlpha(0);
                
                // Request motion permission for iOS
                if (typeof DeviceOrientationEvent !== 'undefined' && 
                    typeof DeviceOrientationEvent.requestPermission === 'function') {
                    document.getElementById('permissionOverlay').style.display = 'flex';
                } else {
                    enableMotionTracking();
                }
                
                showNotification('AR Mode enabled');
            } else {
                stopCamera();
                renderer.setClearAlpha(1);
                state.motionEnabled = false;
                showNotification('AR Mode disabled');
            }
        };

        // Theme toggle
        document.getElementById('themeToggle').onclick = () => {
            document.body.classList.toggle('dark-mode');
            const icon = document.getElementById('themeToggle');
            icon.textContent = document.body.classList.contains('dark-mode') ? '‚òÄÔ∏è' : 'üåô';
        };

        // Permission request
        document.getElementById('requestPermission').onclick = requestMotionPermission;

        // Touch events
        const canvas = document.getElementById('canvas');
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

        // ============================================
        // ANIMATION LOOP
        // ============================================
        
        function animate() {
            requestAnimationFrame(animate);

            // Apply device orientation to camera if motion enabled and model placed
            if (state.motionEnabled && state.modelPlaced) {
                const alpha = THREE.MathUtils.degToRad(deviceOrientation.alpha);
                const beta = THREE.MathUtils.degToRad(deviceOrientation.beta);
                const gamma = THREE.MathUtils.degToRad(deviceOrientation.gamma);
                const orient = THREE.MathUtils.degToRad(screenOrientation);

                camera.rotation.set(beta - Math.PI/2, alpha, -gamma, 'YXZ');
                camera.rotation.z += orient;
            }

            renderer.render(scene, camera);
        }

        // ============================================
        // WINDOW RESIZE
        // ============================================
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ============================================
        // INITIALIZATION
        // ============================================
        
        async function init() {
            showLoading(true);
            
            // Preload first model
            try {
                await loadModel(models[0]);
                showLoading(false);
                showNotification('Ready! Select a model and tap to place');
            } catch (err) {
                console.error('Init error:', err);
                showLoading(false);
                showNotification('Error initializing');
            }
            
            animate();
        }

        init();
    </script>
</body>
</html>
