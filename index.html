<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ArtAR Viewer | Simulador de Realidad Aumentada</title>
    <!-- Carga de Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <!-- Carga de Three.js y OrbitControls para interacción -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Iconos de Lucide React, aunque no es React, los usamos como SVGs -->
    <style>
        /* Estilos personalizados y generales para un look minimalista */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Evita el scroll en el modo AR */
        }
        #ar-canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none; /* Previene gestos por defecto del navegador */
        }
        #video-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 10;
            display: none; /* Inicialmente oculto */
        }
        .gallery-card {
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .gallery-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
        }
        /* Estilo para el modo oscuro por defecto */
        .dark-mode {
            background-color: #1a1a1a;
            color: #f3f4f6;
        }
    </style>
</head>

<body class="dark-mode">

    <!-- 1. Video Background (Cámara) para simulación AR -->
    <video id="video-background" autoplay playsinline></video>

    <!-- 2. Contenedor del Canvas de Three.js -->
    <div id="canvas-container" class="absolute inset-0 z-20">
        <canvas id="ar-canvas"></canvas>
    </div>

    <!-- 3. Pantalla de Galería (Inicial) -->
    <div id="gallery-screen" class="absolute inset-0 z-50 p-4 overflow-y-auto dark-mode transition-opacity duration-500">
        <div class="max-w-7xl mx-auto">
            <h1 class="text-4xl font-extrabold mb-8 text-center pt-8">ArtAR Viewer</h1>
            <p class="text-center mb-10 text-gray-400">Selecciona una obra para visualizarla en tu espacio real (simulación AR).</p>

            <!-- Grid de Obras -->
            <div id="art-gallery" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6 pb-12">
                <!-- Las tarjetas de arte se insertarán aquí por JS -->
            </div>
        </div>
    </div>

    <!-- 4. Controles Flotantes para Modo AR -->
    <div id="ar-controls" class="absolute bottom-4 left-1/2 -translate-x-1/2 z-40 flex flex-wrap justify-center space-x-2 md:space-x-4 p-2 bg-gray-900/70 backdrop-blur-sm rounded-xl transition-opacity duration-300 opacity-0 pointer-events-none">

        <!-- Botón Volver/Cambiar Obra -->
        <button id="btn-back" class="p-3 md:p-4 text-white bg-red-600 hover:bg-red-700 rounded-full shadow-lg transition duration-150 transform hover:scale-105" title="Volver a Galería">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-gallery-vertical-end"><path d="M7 2h10"/><path d="M10 6h4"/><path d="M5 10h14"/><path d="M8 14h8"/><path d="M3 18h18"/><path d="M11 22h2"/></svg>
        </button>

        <!-- Botón Escalar -->
        <button id="btn-scale" data-mode="scale" class="p-3 md:p-4 text-white bg-blue-600 hover:bg-blue-700 rounded-full shadow-lg transition duration-150 transform hover:scale-105 active-mode" title="Modo Escala (Pinch)">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-maximize-2"><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><path d="M21 3 14 10"/><path d="M3 21 10 14"/></svg>
        </button>

        <!-- Botón Mover -->
        <button id="btn-move" data-mode="move" class="p-3 md:p-4 text-white bg-yellow-600 hover:bg-yellow-700 rounded-full shadow-lg transition duration-150 transform hover:scale-105" title="Modo Mover (Arrastrar)">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-move-horizontal"><polyline points="18 8 22 12 18 16"/><polyline points="6 8 2 12 6 16"/><line x1="2" x2="22" y1="12" y2="12"/></svg>
        </button>

        <!-- Botón Rotar -->
        <button id="btn-rotate" data-mode="rotate" class="p-3 md:p-4 text-white bg-green-600 hover:bg-green-700 rounded-full shadow-lg transition duration-150 transform hover:scale-105" title="Modo Rotar (Arrastrar)">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-rotate-3d"><path d="M5.768 18.066a7.957 7.957 0 0 1-2.094-1.244"/><path d="M8.258 20.354a7.957 7.957 0 0 0 4.74-1.424"/><path d="M10.95 21.9a7.957 7.957 0 0 0 1.01-1.285"/><path d="M13.682 20.353a7.957 7.957 0 0 0 4.74-1.424"/><path d="M18.232 18.066a7.957 7.957 0 0 0 2.094-1.244"/><path d="M21.572 13.9a7.957 7.957 0 0 0 .096-1.549"/><path d="M21.5 12.001c0-4.418-3.582-7.999-8-7.999S5.5 7.583 5.5 12.001"/><path d="M5.628 13.901a7.957 7.957 0 0 1-.096-1.55"/><path d="M4.328 16.829a7.957 7.957 0 0 1-1.07-1.353"/><path d="M1.002 12.593a7.957 7.957 0 0 1 1.07-1.353"/><circle cx="12" cy="12" r="10"/></svg>
        </button>

        <!-- Botón Captura/Guardar -->
        <button id="btn-capture" class="p-3 md:p-4 text-white bg-gray-500 hover:bg-gray-600 rounded-full shadow-lg transition duration-150 transform hover:scale-105" title="Guardar Captura">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-camera"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></svg>
        </button>
    </div>

    <!-- 5. Mensaje Flotante (Para Captura o Errores) -->
    <div id="message-box" class="fixed top-4 left-1/2 transform -translate-x-1/2 bg-white text-gray-800 p-3 rounded-lg shadow-xl z-[100] transition-all duration-300 opacity-0 pointer-events-none">
        Mensaje
    </div>


<script>
    // --- Configuración y Datos Iniciales ---
    const ARTWORKS = [
        { id: 'sunflower', name: 'Girasoles', artist: 'Vincent van Gogh', url: 'https://placehold.co/600x900/402830/ffffff?text=Girasoles' },
        { id: 'scream', name: 'El Grito', artist: 'Edvard Munch', url: 'https://placehold.co/600x700/606060/ffffff?text=El+Grito' },
        { id: 'starry', name: 'Noche Estrellada', artist: 'Vincent van Gogh', url: 'https://placehold.co/1000x800/202050/ffffff?text=Noche+Estrellada' },
        { id: 'monalisa', name: 'Mona Lisa', artist: 'Leonardo da Vinci', url: 'https://placehold.co/600x900/7a574a/ffffff?text=Mona+Lisa' },
        { id: 'guernica', name: 'Guernica', artist: 'Pablo Picasso', url: 'https://placehold.co/1600x700/303030/ffffff?text=Guernica' },
    ];

    // --- Variables Globales de Three.js y Estado ---
    let scene, camera, renderer, controls;
    let artObject, currentArtwork, textureLoader;
    let cameraStream = null;

    // Estado de Interacción Táctil
    const interaction = {
        mode: 'move', // 'move', 'scale', 'rotate'
        isDragging: false,
        prevTouch: { x: 0, y: 0 },
        prevDistance: 0,
        initialObjectPosition: new THREE.Vector3()
    };

    // --- Funciones de Utilidad ---

    /** Muestra un mensaje temporal flotante. */
    function showMessage(text, duration = 3000) {
        const msgBox = document.getElementById('message-box');
        msgBox.textContent = text;
        msgBox.classList.remove('opacity-0', 'pointer-events-none');
        msgBox.classList.add('opacity-100');

        setTimeout(() => {
            msgBox.classList.remove('opacity-100');
            msgBox.classList.add('opacity-0', 'pointer-events-none');
        }, duration);
    }

    /** Muestra la galería y oculta el visor AR. */
    function showGalleryView() {
        document.getElementById('gallery-screen').classList.remove('opacity-0', 'pointer-events-none');
        document.getElementById('ar-controls').classList.add('opacity-0', 'pointer-events-none');
        document.getElementById('video-background').style.display = 'none';

        if (artObject) scene.remove(artObject);
        if (cameraStream) {
            cameraStream.getTracks().forEach(track => track.stop());
            cameraStream = null;
        }
        // Limpia el canvas si es necesario (opcional)
        if (renderer) renderer.clear();
    }

    /** Muestra el visor AR y oculta la galería. */
    function showARView() {
        document.getElementById('gallery-screen').classList.add('opacity-0', 'pointer-events-none');
        document.getElementById('ar-controls').classList.remove('opacity-0', 'pointer-events-none');
        document.getElementById('video-background').style.display = 'block';
    }


    // --- Three.js y AR Core ---

    /** Inicializa la escena 3D y el renderer. */
    function initThree() {
        const canvas = document.getElementById('ar-canvas');
        const container = document.getElementById('canvas-container');

        // Escena y Luces
        scene = new THREE.Scene();
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // Cámara (Configurada para AR, alto FOV y cerca del origen)
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 3); // Posición inicial para ver el cuadro

        // Renderer
        renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputEncoding = THREE.sRGBEncoding;

        // Loader
        textureLoader = new THREE.TextureLoader();

        window.addEventListener('resize', onWindowResize);
    }

    /** Maneja el redimensionamiento de la ventana. */
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    /** Inicia la transmisión de video de la cámara. */
    function startCameraFeed() {
        const video = document.getElementById('video-background');

        if (cameraStream) {
            cameraStream.getTracks().forEach(track => track.stop());
        }

        navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } }) // 'environment' para cámara trasera
            .then(stream => {
                cameraStream = stream;
                video.srcObject = stream;
                video.play();
                showMessage('Cámara activada. Coloca la obra en tu espacio.');
            })
            .catch(err => {
                console.error("Error al acceder a la cámara:", err);
                showMessage('Error: No se pudo acceder a la cámara para la simulación AR.', 5000);
            });
    }

    /** Carga la obra 3D con su textura y la añade a la escena. */
    function loadArtwork(artwork) {
        if (artObject) scene.remove(artObject);
        currentArtwork = artwork;

        // Carga de textura
        textureLoader.load(artwork.url,
            // Callback de éxito
            (texture) => {
                // Ajustar el aspecto del plano a la imagen
                const aspectRatio = texture.image.width / texture.image.height;
                const height = 2; // Altura fija del cuadro en el mundo 3D
                const width = height * aspectRatio;

                // 1. Crear la Malla del Arte (el cuadro en sí)
                const artGeometry = new THREE.PlaneGeometry(width, height);
                const artMaterial = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                const artMesh = new THREE.Mesh(artGeometry, artMaterial);
                artMesh.position.z = 0.025; // Pequeño desplazamiento para que no toque el marco

                // 2. Crear el Marco (BoxGeometry)
                const frameThickness = 0.05;
                const frameGeometry = new THREE.BoxGeometry(
                    width + frameThickness * 2,
                    height + frameThickness * 2,
                    frameThickness
                );
                const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.8, roughness: 0.2 });
                const frameMesh = new THREE.Mesh(frameGeometry, frameMaterial);

                // 3. Crear el Objeto Contenedor
                artObject = new THREE.Group();
                artObject.add(frameMesh);
                artObject.add(artMesh);

                // Posición inicial: Flotando un poco más lejos
                artObject.position.set(0, 0, -2);
                artObject.scale.set(1, 1, 1); // Escala inicial
                scene.add(artObject);

                showARView();
                startCameraFeed();
                interaction.initialObjectPosition.copy(artObject.position);

            },
            // Callback de progreso (opcional)
            undefined,
            // Callback de error
            (err) => {
                console.error('Error al cargar la textura de la obra:', err);
                showMessage('Error al cargar la obra. Inténtalo de nuevo.', 5000);
            }
        );
    }

    /** Loop de animación de Three.js. */
    function animate() {
        requestAnimationFrame(animate);
        if (renderer) renderer.render(scene, camera);
    }


    // --- Interacciones Táctiles (Gestos) ---

    function handleTouchStart(event) {
        if (!artObject || event.touches.length === 0) return;

        interaction.isDragging = true;
        interaction.prevTouch.x = event.touches[0].clientX;
        interaction.prevTouch.y = event.touches[0].clientY;

        if (event.touches.length === 2) {
            interaction.prevDistance = getDistance(event.touches[0], event.touches[1]);
        }
    }

    function handleTouchMove(event) {
        if (!artObject || !interaction.isDragging) return;

        // Escala (Pinch/Zoom)
        if (event.touches.length === 2 && interaction.mode === 'scale') {
            const currentDistance = getDistance(event.touches[0], event.touches[1]);
            const deltaDistance = currentDistance - interaction.prevDistance;

            // Ajustar el factor de escala basado en el delta
            const scaleFactor = 0.005;
            const newScale = artObject.scale.x + deltaDistance * scaleFactor;

            // Limitar la escala
            const clampedScale = Math.min(Math.max(0.2, newScale), 5.0);
            artObject.scale.set(clampedScale, clampedScale, clampedScale);

            interaction.prevDistance = currentDistance;
            showMessage(`Escala: ${clampedScale.toFixed(1)}x`, 1000);

        }
        // Movimiento o Rotación (1 dedo)
        else if (event.touches.length === 1) {
            const dx = event.touches[0].clientX - interaction.prevTouch.x;
            const dy = event.touches[0].clientY - interaction.prevTouch.y;

            if (interaction.mode === 'move') {
                // Mover (X e Y de la pantalla mapeados a X y Z del mundo 3D)
                // Usamos la cámara para determinar la dirección de movimiento
                const moveSpeed = 0.005;
                const cameraDirection = new THREE.Vector3();
                camera.getWorldDirection(cameraDirection);

                // Movimiento horizontal (eje X del mundo)
                const sideVector = new THREE.Vector3().crossVectors(cameraDirection, camera.up).normalize();
                artObject.position.add(sideVector.multiplyScalar(-dx * moveSpeed));

                // Movimiento vertical (eje Y del mundo)
                // Se podría mapear 'dy' a mover el objeto hacia/lejos (Z), pero es más intuitivo
                // que mueva el objeto hacia arriba/abajo (Y del mundo).
                artObject.position.y -= dy * moveSpeed;

                showMessage('Moviendo Obra (X, Y, Z)', 1000);
            } else if (interaction.mode === 'rotate') {
                // Rotar (solo eje Y del mundo)
                const rotateSpeed = 0.01;
                artObject.rotation.y += dx * rotateSpeed;
                showMessage('Rotando Obra (Y-axis)', 1000);
            }

            interaction.prevTouch.x = event.touches[0].clientX;
            interaction.prevTouch.y = event.touches[0].clientY;
        }
    }

    function handleTouchEnd(event) {
        if (event.touches.length === 0) {
            interaction.isDragging = false;
        }
        // Si hay toques restantes, actualiza la posición inicial
        if (event.touches.length === 1) {
            interaction.prevTouch.x = event.touches[0].clientX;
            interaction.prevTouch.y = event.touches[0].clientY;
        }
    }

    /** Calcula la distancia entre dos toques para escalado. */
    function getDistance(touch1, touch2) {
        const dx = touch1.clientX - touch2.clientX;
        const dy = touch1.clientY - touch2.clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }


    // --- Inicialización de la Galería y UI ---

    /** Genera las tarjetas de la galería a partir del array ARTWORKS. */
    function generateGalleryCards() {
        const galleryContainer = document.getElementById('art-gallery');
        galleryContainer.innerHTML = ARTWORKS.map(art => `
            <div id="card-${art.id}" data-art-id="${art.id}" class="gallery-card bg-gray-800 rounded-xl overflow-hidden cursor-pointer shadow-lg hover:shadow-2xl">
                <div class="h-64 flex items-center justify-center bg-gray-700">
                    <img src="${art.url}" alt="${art.name}" class="h-full w-full object-cover p-4 opacity-70 transition duration-300 hover:opacity-100">
                </div>
                <div class="p-4">
                    <h3 class="text-xl font-semibold text-white truncate">${art.name}</h3>
                    <p class="text-sm text-gray-400">${art.artist}</p>
                </div>
            </div>
        `).join('');

        // Añadir listeners a las tarjetas
        ARTWORKS.forEach(art => {
            document.getElementById(`card-${art.id}`).addEventListener('click', () => {
                const selectedArt = ARTWORKS.find(a => a.id === art.id);
                if (selectedArt) {
                    loadArtwork(selectedArt);
                }
            });
        });
    }

    /** Configura los listeners de los botones de control en modo AR. */
    function setupARControls() {
        document.getElementById('btn-back').addEventListener('click', showGalleryView);
        document.getElementById('btn-capture').addEventListener('click', captureCanvas);

        // Listeners para cambiar el modo de interacción
        document.querySelectorAll('#ar-controls button').forEach(button => {
            const mode = button.getAttribute('data-mode');
            if (mode) {
                button.addEventListener('click', () => {
                    interaction.mode = mode;
                    showMessage(`Modo cambiado a: ${mode.toUpperCase()}`, 1500);

                    // Resaltar el botón activo
                    document.querySelectorAll('#ar-controls button').forEach(b => b.classList.remove('ring-4', 'ring-offset-2', 'ring-opacity-50', 'ring-white'));
                    button.classList.add('ring-4', 'ring-offset-2', 'ring-opacity-50', 'ring-white');
                });
            }
        });

        // Inicializar el botón de modo 'move' como activo
        document.getElementById('btn-move').click();
    }

    /** Captura el canvas y el video de fondo como una sola imagen. */
    function captureCanvas() {
        if (!renderer || !artObject) {
            showMessage("No hay obra cargada para capturar.", 2000);
            return;
        }

        const video = document.getElementById('video-background');
        const canvas = document.getElementById('ar-canvas');

        // Crear un canvas temporal más grande para combinar
        const finalCanvas = document.createElement('canvas');
        finalCanvas.width = canvas.width;
        finalCanvas.height = canvas.height;
        const ctx = finalCanvas.getContext('2d');

        // 1. Dibujar el fotograma actual del video
        ctx.drawImage(video, 0, 0, finalCanvas.width, finalCanvas.height);

        // 2. Dibujar el contenido del canvas de Three.js encima
        ctx.drawImage(canvas, 0, 0, finalCanvas.width, finalCanvas.height);

        // 3. Crear el enlace de descarga
        const link = document.createElement('a');
        link.download = `artAR_capture_${currentArtwork.id || 'image'}_${Date.now()}.png`;
        link.href = finalCanvas.toDataURL('image/png');
        link.click();

        showMessage('Captura guardada con éxito.', 3000);
    }

    /** Función principal de inicialización de la aplicación. */
    window.onload = function() {
        initThree();
        animate();
        generateGalleryCards();
        setupARControls();

        // Configurar Eventos Táctiles en el Canvas
        const canvas = document.getElementById('ar-canvas');
        canvas.addEventListener('touchstart', handleTouchStart, false);
        canvas.addEventListener('touchmove', handleTouchMove, false);
        canvas.addEventListener('touchend', handleTouchEnd, false);

        // Para escritorio (simulación con OrbitControls, aunque no requerido, mejora el debug)
        if (!('ontouchstart' in window)) {
            // Permite rotación de cámara con OrbitControls en escritorio
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableZoom = true;
            controls.enableDamping = true;
            controls.update();

            // Mapeo básico de ratón para mover/rotar el objeto
            canvas.addEventListener('mousedown', (e) => {
                interaction.isDragging = true;
                interaction.prevTouch.x = e.clientX;
                interaction.prevTouch.y = e.clientY;
            });
            canvas.addEventListener('mousemove', (e) => {
                if (interaction.isDragging && artObject) {
                    const dx = e.clientX - interaction.prevTouch.x;
                    if (interaction.mode === 'rotate') {
                        artObject.rotation.y += dx * 0.01;
                    }
                    interaction.prevTouch.x = e.clientX;
                }
            });
            canvas.addEventListener('mouseup', () => { interaction.isDragging = false; });
        }

        // Mostrar la galería al inicio
        showGalleryView();
    };
</script>

</body>
</html>
