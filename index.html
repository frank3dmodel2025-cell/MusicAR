<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mobile Web AR</title>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
            "three/examples/jsm/loaders/GLTFLoader.js": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/loaders/GLTFLoader.js",
            "three/examples/jsm/controls/DeviceOrientationControls.js": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/controls/DeviceOrientationControls.js"
        }
    }
    </script>

    <style>
        /* CSS Variables for Theming (Light/Dark Mode) */
        :root {
            --bg-color: #ffffff;
            --text-color: #1a1a1a;
            --panel-bg: rgba(255, 255, 255, 0.8);
            --button-bg: #007aff;
            --button-text: #ffffff;
            --reticle-color: #ffffff;
            --shadow-color: rgba(0, 0, 0, 0.5);
        }

        [data-theme="dark"] {
            --bg-color: #1a1a1a;
            --text-color: #f0f0f0;
            --panel-bg: rgba(0, 0, 0, 0.7);
            --button-bg: #0a84ff;
            --button-text: #ffffff;
            --reticle-color: #ffffff;
            --shadow-color: rgba(0, 0, 0, 0.6);
        }

        /* Basic Setup */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Critical for full-screen */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        /* 1. Camera Passthrough (Video) */
        #camera-feed {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover; /* Ensures full-screen, correct aspect ratio */
            z-index: -2;
            display: none; /* Hidden until AR mode is on */
        }

        /* WebGL Canvas (transparent) */
        #webgl-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background-color: transparent;
        }

        /* 6. UI: Permission Overlay (Especially for iOS) */
        #permission-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }
        #permission-overlay h2 {
            font-size: 1.5rem;
            margin-bottom: 10px;
        }
        #permission-overlay p {
            font-size: 1rem;
            margin-bottom: 20px;
            max-width: 300px;
        }
        #permission-button {
            padding: 12px 24px;
            font-size: 1.1rem;
            font-weight: 600;
            background-color: var(--button-bg);
            color: var(--button-text);
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }

        /* 3. AR Placement: Reticle (Dot) */
        #placement-reticle {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 12px;
            height: 12px;
            background-color: var(--reticle-color);
            border: 2px solid var(--shadow-color);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            transition: transform 0.2s ease, opacity 0.2s ease;
            animation: pulse 2s infinite ease-in-out;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(0.9); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(0.9); }
        }

        /* 6. UI: Placement Hint */
        #placement-hint {
            position: fixed;
            top: 70%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
            z-index: 10;
            box-shadow: 0 2px 10px var(--shadow-color);
        }

        /* 6. UI: Main Controls Container */
        #ui-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 15px;
            box-sizing: border-box;
        }

        /* 2. UI: Model Selection */
        #model-switcher {
            display: flex;
            justify-content: center;
            gap: 10px;
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 2px 10px var(--shadow-color);
        }
        #model-switcher button {
            padding: 8px 12px;
            border: none;
            background: transparent;
            color: var(--text-color);
            font-size: 0.9rem;
            font-weight: 500;
            border-radius: 8px;
            transition: background-color 0.2s;
        }
        #model-switcher button.active {
            background-color: var(--button-bg);
            color: var(--button-text);
        }

        /* 6. UI: Sliders Panel */
        #controls-panel {
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 2px 10px var(--shadow-color);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .slider-group label {
            font-size: 0.8rem;
            font-weight: 500;
            width: 60px;
        }
        .slider-group input[type="range"] {
            flex-grow: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 5px;
            background: var(--shadow-color);
            border-radius: 5px;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--button-bg);
            border-radius: 50%;
            cursor: pointer;
        }
        .slider-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--button-bg);
            border-radius: 50%;
            cursor: pointer;
        }

        /* 6. UI: Toggle Buttons */
        #toggle-buttons {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        #toggle-buttons button {
            flex-grow: 1;
            padding: 10px;
            font-size: 0.9rem;
            font-weight: 600;
            background-color: var(--panel-bg);
            color: var(--text-color);
            border: 1px solid var(--shadow-color);
            border-radius: 8px;
            cursor: pointer;
        }

        /* 6. UI: Notification Toast */
        #notification-toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #222;
            color: #fff;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9rem;
            z-index: 101;
            opacity: 0;
            transition: opacity 0.3s ease, top 0.3s ease;
            pointer-events: none;
        }
        #notification-toast.show {
            opacity: 1;
            top: 30px;
        }

        /* Utility class */
        .hidden {
            display: none !important;
        }

    </style>
</head>
<body>

    <video id="camera-feed" playsinline autoplay muted></video>

    <canvas id="webgl-canvas"></canvas>

    <div id="permission-overlay">
        <h2>Welcome to Web AR</h2>
        <p>This experience requires access to your device's camera and motion sensors.</p>
        <button id="permission-button">Enable AR</button>
    </div>

    <div id="placement-reticle" class="hidden"></div>
    
    <div id="placement-hint" class="hidden">Tap to place model</div>

    <div id="ui-container" class="hidden">
        
        <div id="model-switcher">
            <button class="model-btn active" data-model="Astronaut">üßë‚ÄçüöÄ</button>
            <button class="model-btn" data-model="Horse">üêé</button>
            <button class="model-btn" data-model="Shishkebab">üç¢</button>
        </div>

        <div id="controls-panel" class="hidden">
            <div class="slider-group">
                <label for="scale-slider">Scale</label>
                <input type="range" id="scale-slider" min="0.1" max="2" step="0.01" value="0.5">
            </div>
            <div class="slider-group">
                <label for="rotate-y-slider">Rotate Y</label>
                <input type="range" id="rotate-y-slider" min="-180" max="180" step="1" value="0">
            </div>
            <div class="slider-group">
                <label for="position-y-slider">Height</label>
                <input type="range" id="position-y-slider" min="-1" max="1" step="0.01" value="0">
            </div>
        </div>

        <div id="toggle-buttons">
            <button id="relocate-button">Re-Locate</button>
            <button id="ar-toggle-button">AR Mode: ON</button>
            <button id="theme-toggle-button">üåô</button>
        </div>

    </div>

    <div id="notification-toast"></div>

    <script type="module">
        // Import necessary Three.js components
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
        import { DeviceOrientationControls } from 'three/examples/jsm/controls/DeviceOrientationControls.js';

        // --- SECTION 1: CORE THREE.JS & AR VARIABLES ---
        
        let scene, camera, renderer;
        let videoElement;
        let deviceControls;
        let gltfLoader;

        let placedModel = null;
        let shadowPlane;
        let placementMode = true;
        let arMode = true;

        // Store initial placed position for relative adjustments
        const initialPlacedPosition = new THREE.Vector3();
        let initialModelScale = 0.5;

        // Touch gesture state
        let initialPinchDistance = 0;
        let lastTouchX = 0;

        // Model URLs (from Google's Model-Viewer repo)
        const MODELS = {
            'Astronaut': 'https://cdn.gltf.gstop.gcp.core.tools/api/v1/projects/google-model-viewer/models/Astronaut/glTF/Astronaut.gltf',
            'Horse': 'https://cdn.gltf.gstop.gcp.core.tools/api/v1/projects/google-model-viewer/models/Horse/glTF/Horse.gltf',
            'Shishkebab': 'https://cdn.gltf.gstop.gcp.core.tools/api/v1/projects/google-model-viewer/models/Shishkebab/glTF/Shishkebab.gltf'
        };
        let currentModelName = 'Astronaut';

        // DOM Element references
        const permissionOverlay = document.getElementById('permission-overlay');
        const permissionButton = document.getElementById('permission-button');
        const webglCanvas = document.getElementById('webgl-canvas');
        const video = document.getElementById('camera-feed');
        const uiContainer = document.getElementById('ui-container');
        const reticle = document.getElementById('placement-reticle');
        const hint = document.getElementById('placement-hint');
        const controlsPanel = document.getElementById('controls-panel');
        const relocateButton = document.getElementById('relocate-button');
        const arToggleButton = document.getElementById('ar-toggle-button');
        const themeToggleButton = document.getElementById('theme-toggle-button');
        const modelSwitcher = document.getElementById('model-switcher');
        const scaleSlider = document.getElementById('scale-slider');
        const rotateYSlider = document.getElementById('rotate-y-slider');
        const positionYSlider = document.getElementById('position-y-slider');
        const notificationToast = document.getElementById('notification-toast');


        // --- SECTION 2: INITIALIZATION ---

        function init() {
            // Set initial theme
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                document.documentElement.setAttribute('data-theme', 'dark');
                themeToggleButton.textContent = '‚òÄÔ∏è';
            }

            // --- UI Event Listeners ---
            permissionButton.addEventListener('click', requestPermissions);
            relocateButton.addEventListener('click', togglePlacementMode);
            arToggleButton.addEventListener('click', toggleARMode);
            themeToggleButton.addEventListener('click', toggleTheme);
            
            modelSwitcher.addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON') {
                    currentModelName = e.target.dataset.model;
                    modelSwitcher.querySelector('.active').classList.remove('active');
                    e.target.classList.add('active');
                    loadModel(currentModelName);
                    togglePlacementMode(true); // Enter placement mode for new model
                    showToast(`Loading ${currentModelName}...`);
                }
            });

            // Slider Listeners
            scaleSlider.addEventListener('input', updateModelTransform);
            rotateYSlider.addEventListener('input', updateModelTransform);
            positionYSlider.addEventListener('input', updateModelTransform);

            // Gesture Listeners (for pinch/drag)
            webglCanvas.addEventListener('touchstart', onTouchStart, { passive: false });
            webglCanvas.addEventListener('touchmove', onTouchMove, { passive: false });
            webglCanvas.addEventListener('touchend', onTouchEnd);
            
            // Placement Listener
            window.addEventListener('click', onPlaceModel);

            // Resize Listener
            window.addEventListener('resize', onWindowResize);
        }

        /**
         * 6. UI: Handles iOS permission request for motion sensors
         */
        async function requestPermissions() {
            // 1. Request Device Orientation (Motion) permission (for iOS 13+)
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const permissionState = await DeviceOrientationEvent.requestPermission();
                    if (permissionState !== 'granted') {
                        alert('Motion sensor permission is required for AR.');
                        return;
                    }
                } catch (error) {
                    console.error('Error requesting motion permission:', error);
                    alert('Failed to get motion sensor permissions.');
                    return;
                }
            }
            
            // 2. Request Camera permission
            startCamera();
        }

        /**
         * 1. Camera Passthrough: Accesses back-facing camera
         */
        function startCamera() {
            navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: 'environment' } // 'environment' = back camera
            })
            .then(stream => {
                video.srcObject = stream;
                video.style.display = 'block'; // Show video feed
                video.play();

                // Once video is playing, setup the 3D scene
                video.onloadedmetadata = () => {
                    setupThreeScene();
                    // Show UI
                    permissionOverlay.classList.add('hidden');
                    uiContainer.classList.remove('hidden');
                    reticle.classList.remove('hidden');
                    hint.classList.remove('hidden');
                };
            })
            .catch(err => {
                console.error("Error accessing camera: ", err);
                alert("Could not access the camera. Please ensure permissions are granted.");
                permissionOverlay.classList.remove('hidden'); // Show overlay again
            });
        }

        /**
         * Sets up the core Three.js scene, camera, renderer, and lights
         */
        function setupThreeScene() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 0); // Position at origin

            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: webglCanvas, 
                alpha: true // Key for transparent background
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true; // 5. Enable Shadows
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // 5. Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true;
            // Configure shadow map
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            scene.add(directionalLight);

            // 5. Shadow Plane (invisible, catches shadows)
            const shadowPlaneGeo = new THREE.PlaneGeometry(10, 10);
            const shadowMaterial = new THREE.ShadowMaterial({ opacity: 0.5 });
            shadowPlane = new THREE.Mesh(shadowPlaneGeo, shadowMaterial);
            shadowPlane.receiveShadow = true;
            shadowPlane.rotation.x = -Math.PI / 2; // Lay flat
            shadowPlane.visible = false; // Hide until model is placed
            scene.add(shadowPlane);

            // 4. Device Motion Integration
            deviceControls = new DeviceOrientationControls(camera);

            // Loaders
            gltfLoader = new GLTFLoader();

            // Load the initial model
            loadModel(currentModelName);

            // Start animation loop
            animate();
        }

        // --- SECTION 3: CORE LOGIC (MODEL LOADING & PLACEMENT) ---

        /**
         * 2. 3D Model Handling: Loads a GLB/GLTF model
         */
        function loadModel(modelName) {
            if (!MODELS[modelName]) return;

            // Remove old model if it exists
            if (placedModel) {
                scene.remove(placedModel);
                placedModel = null;
            }

            gltfLoader.load(MODELS[modelName], (gltf) => {
                placedModel = gltf.scene;
                
                // Enable shadows for all meshes in the model
                placedModel.traverse((node) => {
                    if (node.isMesh) {
                        node.castShadow = true;
                    }
                });

                placedModel.visible = false; // Hide until placed
                scene.add(placedModel);
                
                // Reset sliders to default
                resetSliders();
                updateModelTransform();

                showToast(`${modelName} loaded.`);
            }, undefined, (error) => {
                console.error('Error loading model:', error);
                showToast(`Error loading ${modelName}.`);
            });
        }

        /**
         * 3. AR Placement: Called on tap
         */
        function onPlaceModel(event) {
            // Ignore taps on UI elements
            if (event.target.closest('#ui-container')) {
                return;
            }

            if (placementMode && placedModel) {
                // Get screen center (where reticle is)
                const placementVector = new THREE.Vector3(0, 0, -2.5); // 2.5 units in front
                
                // Project this local-camera vector into world space
                placementVector.applyMatrix4(camera.matrixWorld);
                
                // Store this as the "base" position
                initialPlacedPosition.copy(placementVector);
                
                // Apply slider offsets
                updateModelTransform();
                
                // Make model and shadow visible
                placedModel.visible = true;
                shadowPlane.visible = true;

                // Toggle UI state
                placementMode = false;
                reticle.classList.add('hidden');
                hint.classList.add('hidden');
                controlsPanel.classList.remove('hidden');

                showToast('Model placed!');
            }
        }

        /**
         * 3. AR Placement: Re-enters placement mode
         */
        function togglePlacementMode(force = false) {
            if (force === true) {
                placementMode = true;
            } else {
                placementMode = !placementMode;
            }

            if (placementMode) {
                if (placedModel) placedModel.visible = false;
                shadowPlane.visible = false;
                reticle.classList.remove('hidden');
                hint.classList.remove('hidden');
                controlsPanel.classList.add('hidden');
                showToast('Tap to place model.');
            }
        }


        // --- SECTION 4: ANIMATION & EVENT HANDLERS ---

        /**
         * Main animation loop
         */
        function animate() {
            requestAnimationFrame(animate);

            // 4. Update camera rotation from device motion
            if (arMode && deviceControls) {
                deviceControls.update();
            }

            renderer.render(scene, camera);
        }

        /**
         * 7. Responsive: Handle window resize
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /**
         * 4. Device Motion: Updates model based on slider values
         */
        function updateModelTransform() {
            if (!placedModel) return;

            // Get values from sliders
            const scale = parseFloat(scaleSlider.value);
            const rotationY = THREE.MathUtils.degToRad(parseFloat(rotateYSlider.value));
            const positionY = parseFloat(positionYSlider.value);

            // Apply scale
            placedModel.scale.set(scale, scale, scale);
            initialModelScale = scale; // Store for pinch-to-zoom

            // Apply rotation
            placedModel.rotation.y = rotationY;

            // Apply position (relative to initial placed point)
            const newPos = initialPlacedPosition.clone();
            newPos.y += positionY;
            placedModel.position.copy(newPos);

            // 5. Update shadow plane to be at the base of the model
            shadowPlane.position.copy(placedModel.position);
            shadowPlane.position.y = initialPlacedPosition.y - 0.01; // Place just under the base
            shadowPlane.rotation.x = -Math.PI / 2;
        }

        /**
         * 4. Device Motion: Resets sliders to default
         */
        function resetSliders() {
            scaleSlider.value = 0.5;
            rotateYSlider.value = 0;
            positionYSlider.value = 0;
        }

        // --- SECTION 5: TOUCH GESTURES (PINCH & DRAG) ---

        function onTouchStart(e) {
            if (placementMode || !placedModel) return;
            e.preventDefault();

            if (e.touches.length === 1) { // Drag to rotate
                lastTouchX = e.touches[0].clientX;
            } else if (e.touches.length === 2) { // Pinch to scale
                initialPinchDistance = getPinchDistance(e.touches);
                initialModelScale = placedModel.scale.x;
            }
        }

        function onTouchMove(e) {
            if (placementMode || !placedModel) return;
            e.preventDefault();

            if (e.touches.length === 1) { // Drag to rotate
                const dx = e.touches[0].clientX - lastTouchX;
                const newRotation = placedModel.rotation.y + (dx * 0.01);
                
                placedModel.rotation.y = newRotation;
                // Update slider
                rotateYSlider.value = THREE.MathUtils.radToDeg(newRotation) % 360;
                
                lastTouchX = e.touches[0].clientX;

            } else if (e.touches.length === 2) { // Pinch to scale
                const dist = getPinchDistance(e.touches);
                const scaleFactor = dist / initialPinchDistance;
                let newScale = initialModelScale * scaleFactor;

                // Clamp scale
                newScale = Math.max(0.1, Math.min(newScale, 2.0));
                
                placedModel.scale.set(newScale, newScale, newScale);
                // Update slider
                scaleSlider.value = newScale;
            }
        }

        function onTouchEnd(e) {
            // Reset gesture state
            initialPinchDistance = 0;
            lastTouchX = 0;
        }

        function getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // --- SECTION 6: UI & UTILITY FUNCTIONS ---

        /**
         * 6. UI: Toggles AR mode (camera + motion) on/off
         */
        function toggleARMode() {
            arMode = !arMode;
            if (arMode) {
                video.style.display = 'block';
                deviceControls.connect(); // Re-enable motion controls
                arToggleButton.textContent = 'AR Mode: ON';
                document.documentElement.style.background = 'transparent';
            } else {
                video.style.display = 'none';
                deviceControls.disconnect(); // Disable motion controls
                arToggleButton.textContent = 'AR Mode: OFF';
                // Set a fallback background
                document.documentElement.style.background = (document.documentElement.getAttribute('data-theme') === 'dark') ? '#1a1a1a' : '#ffffff';
                // Reset camera orientation
                camera.position.set(0, 0, 0);
                camera.lookAt(0, 0, -1);
            }
        }

        /**
         * 8. Optional: Light/Dark mode toggle
         */
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            if (currentTheme === 'dark') {
                document.documentElement.setAttribute('data-theme', 'light');
                themeToggleButton.textContent = 'üåô';
            } else {
                document.documentElement.setAttribute('data-theme', 'dark');
                themeToggleButton.textContent = '‚òÄÔ∏è';
            }
            // Update non-AR background color
            if (!arMode) {
                document.documentElement.style.background = (document.documentElement.getAttribute('data-theme') === 'dark') ? '#1a1a1a' : '#ffffff';
            }
        }

        /**
         * 6. UI: Shows a temporary notification toast
         */
        let toastTimeout;
        function showToast(message) {
            if (toastTimeout) clearTimeout(toastTimeout);
            
            notificationToast.textContent = message;
            notificationToast.classList.add('show');
            
            toastTimeout = setTimeout(() => {
                notificationToast.classList.remove('show');
            }, 2500);
        }

        // --- GO! ---
        init();

    </script>
</body>
</html>
